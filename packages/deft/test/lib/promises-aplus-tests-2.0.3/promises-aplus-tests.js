(function (){
    describe("Promises/A+ Compliance Test Suite v2.0.3", function () {
        "use strict";

        var global = {
            adapter: {
                deferred: function () { return Ext.create( 'Deft.Deferred' ) },
                resolved: Deft.Deferred.resolve,
                rejected: Deft.Deferred.reject
            }
        };
        
        // Manual browserification.
        var modules = {
            assert: chai.assert,
            sinon: sinon,
            reasons: {},
            testThreeCases: {},
            thenables: {}
        }
        function require( name ) {
            switch ( name ) {
                case 'assert':
                    return modules.assert;
                case 'sinon':
                    return modules.sinon;
                case './helpers/reasons':
                    return modules.reasons;
                case './helpers/testThreeCases':
                    return modules.testThreeCases;
                case './helpers/thenables':
                    return modules.thenables;
                default:
                    throw new Error( 'Unsupported dependency: ' + name );
            }
        }

// File: helpers/testThreeCases.js
(function(exports){
    "use strict";

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;
    var deferred = adapter.deferred;

    exports.testFulfilled = function (value, test) {
        specify("already-fulfilled", function (done) {
            test(resolved(value), done);
        });

        specify("immediately-fulfilled", function (done) {
            var d = deferred();
            test(d.promise, done);
            d.resolve(value);
        });

        specify("eventually-fulfilled", function (done) {
            var d = deferred();
            test(d.promise, done);
            setTimeout(function () {
                d.resolve(value);
            }, 50);
        });
    };

	exports.testRejected = function (reason, test) {
        specify("already-rejected", function (done) {
            test(rejected(reason), done);
        });

        specify("immediately-rejected", function (done) {
            var d = deferred();
            test(d.promise, done);
            d.reject(reason);
        });

        specify("eventually-rejected", function (done) {
            var d = deferred();
            test(d.promise, done);
            setTimeout(function () {
                d.reject(reason);
            }, 50);
        });
    };
})(modules.testThreeCases);

// File: helpers/reasons.js
(function(exports){
    "use strict";

    // This module exports some valid rejection reason factories, keyed by human-readable versions of their names.

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;

    var dummy = { dummy: "dummy" };

    exports["`undefined`"] = function () {
        return undefined;
    };

    exports["`null`"] = function () {
        return null;
    };

    exports["`false`"] = function () {
        return false;
    };

    exports["`0`"] = function () {
        return 0;
    };

    exports["an error"] = function () {
        return new Error();
    };

    exports["an error without a stack"] = function () {
        var error = new Error();
        delete error.stack;

        return error;
    };

    exports["a date"] = function () {
        return new Date();
    };

    exports["an object"] = function () {
        return {};
    };

    exports["an always-pending thenable"] = function () {
        return { then: function () { } };
    };

    exports["a fulfilled promise"] = function () {
        return resolved(dummy);
    };

    exports["a rejected promise"] = function () {
        return rejected(dummy);
    };
})(modules.reasons);

// File: helpers/thenables.js
(function(exports){
    "use strict";
    
    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;
    var deferred = adapter.deferred;

    var other = { other: "other" }; // a value we don't want to be strict equal to

    exports.fulfilled = {
        "a synchronously-fulfilled custom thenable": function (value) {
            return {
                then: function (onFulfilled) {
                    onFulfilled(value);
                }
            };
        },

        "an asynchronously-fulfilled custom thenable": function (value) {
            return {
                then: function (onFulfilled) {
                    setTimeout(function () {
                        onFulfilled(value);
                    }, 0);
                }
            };
        },

        "a synchronously-fulfilled one-time thenable": function (value) {
            var numberOfTimesThenRetrieved = 0;
            return Object.create(null, {
                then: {
                    get: function () {
                        if (numberOfTimesThenRetrieved === 0) {
                            ++numberOfTimesThenRetrieved;
                            return function (onFulfilled) {
                                onFulfilled(value);
                            };
                        }
                        return null;
                    }
                }
            });
        },

        "a thenable that tries to fulfill twice": function (value) {
            return {
                then: function (onFulfilled) {
                    onFulfilled(value);
                    onFulfilled(other);
                }
            };
        },

        "a thenable that fulfills but then throws": function (value) {
            return {
                then: function (onFulfilled) {
                    onFulfilled(value);
                    throw other;
                }
            };
        },

        "an already-fulfilled promise": function (value) {
            return resolved(value);
        },

        "an eventually-fulfilled promise": function (value) {
            var d = deferred();
            setTimeout(function () {
                d.resolve(value);
            }, 50);
            return d.promise;
        }
    };

    exports.rejected = {
        "a synchronously-rejected custom thenable": function (reason) {
            return {
                then: function (onFulfilled, onRejected) {
                    onRejected(reason);
                }
            };
        },

        "an asynchronously-rejected custom thenable": function (reason) {
            return {
                then: function (onFulfilled, onRejected) {
                    setTimeout(function () {
                        onRejected(reason);
                    }, 0);
                }
            };
        },

        "a synchronously-rejected one-time thenable": function (reason) {
            var numberOfTimesThenRetrieved = 0;
            return Object.create(null, {
                then: {
                    get: function () {
                        if (numberOfTimesThenRetrieved === 0) {
                            ++numberOfTimesThenRetrieved;
                            return function (onFulfilled, onRejected) {
                                onRejected(reason);
                            };
                        }
                        return null;
                    }
                }
            });
        },

        "a thenable that immediately throws in `then`": function (reason) {
            return {
                then: function () {
                    throw reason;
                }
            };
        },

        "an object with a throwing `then` accessor": function (reason) {
            return Object.create(null, {
                then: {
                    get: function () {
                        throw reason;
                    }
                }
            });
        },

        "an already-rejected promise": function (reason) {
            return rejected(reason);
        },

        "an eventually-rejected promise": function (reason) {
            var d = deferred();
            setTimeout(function () {
                d.reject(reason);
            }, 50);
            return d.promise;
        }
    };
})(modules.thenables);

// File: 2.1.2.js
(function(){
    "use strict";

    var assert = require("assert");
    var testFulfilled = require("./helpers/testThreeCases").testFulfilled;

    var adapter = global.adapter;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.1.2.1: When fulfilled, a promise: must not transition to any other state.", function () {
        testFulfilled(dummy, function (promise, done) {
            var onFulfilledCalled = false;

            promise.then(function onFulfilled() {
                onFulfilledCalled = true;
            }, function onRejected() {
                assert.strictEqual(onFulfilledCalled, false);
                done();
            });

            setTimeout(done, 100);
        });

        specify("trying to fulfill then immediately reject", function (done) {
            var d = deferred();
            var onFulfilledCalled = false;

            d.promise.then(function onFulfilled() {
                onFulfilledCalled = true;
            }, function onRejected() {
                assert.strictEqual(onFulfilledCalled, false);
                done();
            });

            d.resolve(dummy);
            d.reject(dummy);
            setTimeout(done, 100);
        });

        specify("trying to fulfill then reject, delayed", function (done) {
            var d = deferred();
            var onFulfilledCalled = false;

            d.promise.then(function onFulfilled() {
                onFulfilledCalled = true;
            }, function onRejected() {
                assert.strictEqual(onFulfilledCalled, false);
                done();
            });

            setTimeout(function () {
                d.resolve(dummy);
                d.reject(dummy);
            }, 50);
            setTimeout(done, 100);
        });

        specify("trying to fulfill immediately then reject delayed", function (done) {
            var d = deferred();
            var onFulfilledCalled = false;

            d.promise.then(function onFulfilled() {
                onFulfilledCalled = true;
            }, function onRejected() {
                assert.strictEqual(onFulfilledCalled, false);
                done();
            });

            d.resolve(dummy);
            setTimeout(function () {
                d.reject(dummy);
            }, 50);
            setTimeout(done, 100);
        });
    });
})();

// File: 2.1.3.js
(function(){
    "use strict";

    var assert = require("assert");
    var testRejected = require("./helpers/testThreeCases").testRejected;

    var adapter = global.adapter;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.1.3.1: When rejected, a promise: must not transition to any other state.", function () {
        testRejected(dummy, function (promise, done) {
            var onRejectedCalled = false;

            promise.then(function onFulfilled() {
                assert.strictEqual(onRejectedCalled, false);
                done();
            }, function onRejected() {
                onRejectedCalled = true;
            });

            setTimeout(done, 100);
        });

        specify("trying to reject then immediately fulfill", function (done) {
            var d = deferred();
            var onRejectedCalled = false;

            d.promise.then(function onFulfilled() {
                assert.strictEqual(onRejectedCalled, false);
                done();
            }, function onRejected() {
                onRejectedCalled = true;
            });

            d.reject(dummy);
            d.resolve(dummy);
            setTimeout(done, 100);
        });

        specify("trying to reject then fulfill, delayed", function (done) {
            var d = deferred();
            var onRejectedCalled = false;

            d.promise.then(function onFulfilled() {
                assert.strictEqual(onRejectedCalled, false);
                done();
            }, function onRejected() {
                onRejectedCalled = true;
            });

            setTimeout(function () {
                d.reject(dummy);
                d.resolve(dummy);
            }, 50);
            setTimeout(done, 100);
        });

        specify("trying to reject immediately then fulfill delayed", function (done) {
            var d = deferred();
            var onRejectedCalled = false;

            d.promise.then(function onFulfilled() {
                assert.strictEqual(onRejectedCalled, false);
                done();
            }, function onRejected() {
                onRejectedCalled = true;
            });

            d.reject(dummy);
            setTimeout(function () {
                d.resolve(dummy);
            }, 50);
            setTimeout(done, 100);
        });
    });
})();

// File: 2.2.1.js
(function(){
    "use strict";

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.2.1: Both `onFulfilled` and `onRejected` are optional arguments.", function () {
        describe("2.2.1.1: If `onFulfilled` is not a function, it must be ignored.", function () {
            describe("applied to a directly-rejected promise", function () {
                function testNonFunction(nonFunction, stringRepresentation) {
                    specify("`onFulfilled` is " + stringRepresentation, function (done) {
                        rejected(dummy).then(nonFunction, function () {
                            done();
                        });
                    });
                }

                testNonFunction(undefined, "`undefined`");
                testNonFunction(null, "`null`");
                testNonFunction(false, "`false`");
                testNonFunction(5, "`5`");
                testNonFunction({}, "an object");
            });

            describe("applied to a promise rejected and then chained off of", function () {
                function testNonFunction(nonFunction, stringRepresentation) {
                    specify("`onFulfilled` is " + stringRepresentation, function (done) {
                        rejected(dummy).then(function () { }, undefined).then(nonFunction, function () {
                            done();
                        });
                    });
                }

                testNonFunction(undefined, "`undefined`");
                testNonFunction(null, "`null`");
                testNonFunction(false, "`false`");
                testNonFunction(5, "`5`");
                testNonFunction({}, "an object");
            });
        });

        describe("2.2.1.2: If `onRejected` is not a function, it must be ignored.", function () {
            describe("applied to a directly-fulfilled promise", function () {
                function testNonFunction(nonFunction, stringRepresentation) {
                    specify("`onRejected` is " + stringRepresentation, function (done) {
                        resolved(dummy).then(function () {
                            done();
                        }, nonFunction);
                    });
                }

                testNonFunction(undefined, "`undefined`");
                testNonFunction(null, "`null`");
                testNonFunction(false, "`false`");
                testNonFunction(5, "`5`");
                testNonFunction({}, "an object");
            });

            describe("applied to a promise fulfilled and then chained off of", function () {
                function testNonFunction(nonFunction, stringRepresentation) {
                    specify("`onFulfilled` is " + stringRepresentation, function (done) {
                        resolved(dummy).then(undefined, function () { }).then(function () {
                            done();
                        }, nonFunction);
                    });
                }

                testNonFunction(undefined, "`undefined`");
                testNonFunction(null, "`null`");
                testNonFunction(false, "`false`");
                testNonFunction(5, "`5`");
                testNonFunction({}, "an object");
            });
        });
    });
})();

// File: 2.2.2.js
(function(){
    "use strict";

    var assert = require("assert");
    var testFulfilled = require("./helpers/testThreeCases").testFulfilled;

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it
    var sentinel = { sentinel: "sentinel" }; // a sentinel fulfillment value to test for with strict equality

    describe("2.2.2: If `onFulfilled` is a function,", function () {
        describe("2.2.2.1: it must be called after `promise` is fulfilled, with `promise`’s fulfillment value as its " +
                 "first argument.", function () {
            testFulfilled(sentinel, function (promise, done) {
                promise.then(function onFulfilled(value) {
                    assert.strictEqual(value, sentinel);
                    done();
                });
            });
        });

        describe("2.2.2.2: it must not be called before `promise` is fulfilled", function () {
            specify("fulfilled after a delay", function (done) {
                var d = deferred();
                var isFulfilled = false;

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(isFulfilled, true);
                    done();
                });

                setTimeout(function () {
                    d.resolve(dummy);
                    isFulfilled = true;
                }, 50);
            });

            specify("never fulfilled", function (done) {
                var d = deferred();
                var onFulfilledCalled = false;

                d.promise.then(function onFulfilled() {
                    onFulfilledCalled = true;
                    done();
                });

                setTimeout(function () {
                    assert.strictEqual(onFulfilledCalled, false);
                    done();
                }, 150);
            });
        });

        describe("2.2.2.3: it must not be called more than once.", function () {
            specify("already-fulfilled", function (done) {
                var timesCalled = 0;

                resolved(dummy).then(function onFulfilled() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });
            });

            specify("trying to fulfill a pending promise more than once, immediately", function (done) {
                var d = deferred();
                var timesCalled = 0;

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });

                d.resolve(dummy);
                d.resolve(dummy);
            });

            specify("trying to fulfill a pending promise more than once, delayed", function (done) {
                var d = deferred();
                var timesCalled = 0;

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });

                setTimeout(function () {
                    d.resolve(dummy);
                    d.resolve(dummy);
                }, 50);
            });

            specify("trying to fulfill a pending promise more than once, immediately then delayed", function (done) {
                var d = deferred();
                var timesCalled = 0;

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });

                d.resolve(dummy);
                setTimeout(function () {
                    d.resolve(dummy);
                }, 50);
            });

            specify("when multiple `then` calls are made, spaced apart in time", function (done) {
                var d = deferred();
                var timesCalled = [0, 0, 0];

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(++timesCalled[0], 1);
                });

                setTimeout(function () {
                    d.promise.then(function onFulfilled() {
                        assert.strictEqual(++timesCalled[1], 1);
                    });
                }, 50);

                setTimeout(function () {
                    d.promise.then(function onFulfilled() {
                        assert.strictEqual(++timesCalled[2], 1);
                        done();
                    });
                }, 100);

                setTimeout(function () {
                    d.resolve(dummy);
                }, 150);
            });

            specify("when `then` is interleaved with fulfillment", function (done) {
                var d = deferred();
                var timesCalled = [0, 0];

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(++timesCalled[0], 1);
                });

                d.resolve(dummy);

                d.promise.then(function onFulfilled() {
                    assert.strictEqual(++timesCalled[1], 1);
                    done();
                });
            });
        });
    });
})();

// File: 2.2.3.js
(function(){
    "use strict";

    var assert = require("assert");
    var testRejected = require("./helpers/testThreeCases").testRejected;

    var adapter = global.adapter;
    var rejected = adapter.rejected;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it
    var sentinel = { sentinel: "sentinel" }; // a sentinel fulfillment value to test for with strict equality

    describe("2.2.3: If `onRejected` is a function,", function () {
        describe("2.2.3.1: it must be called after `promise` is rejected, with `promise`’s rejection reason as its " +
                 "first argument.", function () {
            testRejected(sentinel, function (promise, done) {
                promise.then(null, function onRejected(reason) {
                    assert.strictEqual(reason, sentinel);
                    done();
                });
            });
        });

        describe("2.2.3.2: it must not be called before `promise` is rejected", function () {
            specify("rejected after a delay", function (done) {
                var d = deferred();
                var isRejected = false;

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(isRejected, true);
                    done();
                });

                setTimeout(function () {
                    d.reject(dummy);
                    isRejected = true;
                }, 50);
            });

            specify("never rejected", function (done) {
                var d = deferred();
                var onRejectedCalled = false;

                d.promise.then(null, function onRejected() {
                    onRejectedCalled = true;
                    done();
                });

                setTimeout(function () {
                    assert.strictEqual(onRejectedCalled, false);
                    done();
                }, 150);
            });
        });

        describe("2.2.3.3: it must not be called more than once.", function () {
            specify("already-rejected", function (done) {
                var timesCalled = 0;

                rejected(dummy).then(null, function onRejected() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });
            });

            specify("trying to reject a pending promise more than once, immediately", function (done) {
                var d = deferred();
                var timesCalled = 0;

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });

                d.reject(dummy);
                d.reject(dummy);
            });

            specify("trying to reject a pending promise more than once, delayed", function (done) {
                var d = deferred();
                var timesCalled = 0;

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });

                setTimeout(function () {
                    d.reject(dummy);
                    d.reject(dummy);
                }, 50);
            });

            specify("trying to reject a pending promise more than once, immediately then delayed", function (done) {
                var d = deferred();
                var timesCalled = 0;

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(++timesCalled, 1);
                    done();
                });

                d.reject(dummy);
                setTimeout(function () {
                    d.reject(dummy);
                }, 50);
            });

            specify("when multiple `then` calls are made, spaced apart in time", function (done) {
                var d = deferred();
                var timesCalled = [0, 0, 0];

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(++timesCalled[0], 1);
                });

                setTimeout(function () {
                    d.promise.then(null, function onRejected() {
                        assert.strictEqual(++timesCalled[1], 1);
                    });
                }, 50);

                setTimeout(function () {
                    d.promise.then(null, function onRejected() {
                        assert.strictEqual(++timesCalled[2], 1);
                        done();
                    });
                }, 100);

                setTimeout(function () {
                    d.reject(dummy);
                }, 150);
            });

            specify("when `then` is interleaved with rejection", function (done) {
                var d = deferred();
                var timesCalled = [0, 0];

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(++timesCalled[0], 1);
                });

                d.reject(dummy);

                d.promise.then(null, function onRejected() {
                    assert.strictEqual(++timesCalled[1], 1);
                    done();
                });
            });
        });
    });
})();

// File: 2.2.4.js
(function(){
    "use strict";

    var assert = require("assert");
    var testFulfilled = require("./helpers/testThreeCases").testFulfilled;
    var testRejected = require("./helpers/testThreeCases").testRejected;

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.2.4: `onFulfilled` or `onRejected` must not be called until the execution context stack contains only " +
             "platform code.", function () {
        describe("`then` returns before the promise becomes fulfilled or rejected", function () {
            testFulfilled(dummy, function (promise, done) {
                var thenHasReturned = false;

                promise.then(function onFulfilled() {
                    assert.strictEqual(thenHasReturned, true);
                    done();
                });

                thenHasReturned = true;
            });
            testRejected(dummy, function (promise, done) {
                var thenHasReturned = false;

                promise.then(null, function onRejected() {
                    assert.strictEqual(thenHasReturned, true);
                    done();
                });

                thenHasReturned = true;
            });
        });

        describe("Clean-stack execution ordering tests (fulfillment case)", function () {
            specify("when `onFulfilled` is added immediately before the promise is fulfilled",
                    function () {
                var d = deferred();
                var onFulfilledCalled = false;

                d.promise.then(function onFulfilled() {
                    onFulfilledCalled = true;
                });

                d.resolve(dummy);

                assert.strictEqual(onFulfilledCalled, false);
            });

            specify("when `onFulfilled` is added immediately after the promise is fulfilled",
                    function () {
                var d = deferred();
                var onFulfilledCalled = false;

                d.resolve(dummy);

                d.promise.then(function onFulfilled() {
                    onFulfilledCalled = true;
                });

                assert.strictEqual(onFulfilledCalled, false);
            });

            specify("when one `onFulfilled` is added inside another `onFulfilled`", function (done) {
                var promise = resolved();
                var firstOnFulfilledFinished = false;

                promise.then(function () {
                    promise.then(function () {
                        assert.strictEqual(firstOnFulfilledFinished, true);
                        done();
                    });
                    firstOnFulfilledFinished = true;
                });
            });

            specify("when `onFulfilled` is added inside an `onRejected`", function (done) {
                var promise = rejected();
                var promise2 = resolved();
                var firstOnRejectedFinished = false;

                promise.then(null, function () {
                    promise2.then(function () {
                        assert.strictEqual(firstOnRejectedFinished, true);
                        done();
                    });
                    firstOnRejectedFinished = true;
                });
            });

            specify("when the promise is fulfilled asynchronously", function (done) {
                var d = deferred();
                var firstStackFinished = false;

                setTimeout(function () {
                    d.resolve(dummy);
                    firstStackFinished = true;
                }, 0);

                d.promise.then(function () {
                    assert.strictEqual(firstStackFinished, true);
                    done();
                });
            });
        });

        describe("Clean-stack execution ordering tests (rejection case)", function () {
            specify("when `onRejected` is added immediately before the promise is rejected",
                    function () {
                var d = deferred();
                var onRejectedCalled = false;

                d.promise.then(null, function onRejected() {
                    onRejectedCalled = true;
                });

                d.reject(dummy);

                assert.strictEqual(onRejectedCalled, false);
            });

            specify("when `onRejected` is added immediately after the promise is rejected",
                    function () {
                var d = deferred();
                var onRejectedCalled = false;

                d.reject(dummy);

                d.promise.then(null, function onRejected() {
                    onRejectedCalled = true;
                });

                assert.strictEqual(onRejectedCalled, false);
            });

            specify("when `onRejected` is added inside an `onFulfilled`", function (done) {
                var promise = resolved();
                var promise2 = rejected();
                var firstOnFulfilledFinished = false;

                promise.then(function () {
                    promise2.then(null, function () {
                        assert.strictEqual(firstOnFulfilledFinished, true);
                        done();
                    });
                    firstOnFulfilledFinished = true;
                });
            });

            specify("when one `onRejected` is added inside another `onRejected`", function (done) {
                var promise = rejected();
                var firstOnRejectedFinished = false;

                promise.then(null, function () {
                    promise.then(null, function () {
                        assert.strictEqual(firstOnRejectedFinished, true);
                        done();
                    });
                    firstOnRejectedFinished = true;
                });
            });

            specify("when the promise is rejected asynchronously", function (done) {
                var d = deferred();
                var firstStackFinished = false;

                setTimeout(function () {
                    d.reject(dummy);
                    firstStackFinished = true;
                }, 0);

                d.promise.then(null, function () {
                    assert.strictEqual(firstStackFinished, true);
                    done();
                });
            });
        });
    });
})();

// File: 2.2.5.js
(function(){
    /*jshint strict: false */

    var assert = require("assert");

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.2.5 `onFulfilled` and `onRejected` must be called as functions (i.e. with no `this` value).", function () {
        describe("strict mode", function () {
            specify("fulfilled", function (done) {
                // Make the tests tolerant of older environments which don't have the correct semantics for `this` in strict mode
                // (e.g. because they don't implement strict mode at all).
                var defaultThisStrict = (function () {
                    "use strict";
                    return this;
                }());

                resolved(dummy).then(function onFulfilled() {
                    "use strict";

                    assert.strictEqual(this, defaultThisStrict);
                    done();
                });
            });

            specify("rejected", function (done) {
                var defaultThisStrict = (function () {
                    "use strict";
                     return this;
                }());

                rejected(dummy).then(null, function onRejected() {
                    "use strict";

                    assert.strictEqual(this, defaultThisStrict);
                    done();
                });
            });
        });

        describe("sloppy mode", function () {
            specify("fulfilled", function (done) {
                var defaultThisSloppy = (function () {
                    return this;
                }());

                resolved(dummy).then(function onFulfilled() {
                    assert.strictEqual(this, defaultThisSloppy);
                    done();
                });
            });

            specify("rejected", function (done) {
                var defaultThisSloppy = (function () {
                    return this;
                }());

                rejected(dummy).then(null, function onRejected() {
                    assert.strictEqual(this, defaultThisSloppy);
                    done();
                });
            });
        });
    });
})();

// File: 2.2.6.js
(function(){
    "use strict";

    var assert = require("assert");
    var sinon = require("sinon");
    var testFulfilled = require("./helpers/testThreeCases").testFulfilled;
    var testRejected = require("./helpers/testThreeCases").testRejected;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it
    var other = { other: "other" }; // a value we don't want to be strict equal to
    var sentinel = { sentinel: "sentinel" }; // a sentinel fulfillment value to test for with strict equality
    var sentinel2 = { sentinel2: "sentinel2" };
    var sentinel3 = { sentinel3: "sentinel3" };

    function callbackAggregator(times, ultimateCallback) {
        var soFar = 0;
        return function () {
            if (++soFar === times) {
                ultimateCallback();
            }
        };
    }

    describe("2.2.6: `then` may be called multiple times on the same promise.", function () {
        describe("2.2.6.1: If/when `promise` is fulfilled, all respective `onFulfilled` callbacks must execute in the " +
                 "order of their originating calls to `then`.", function () {
            describe("multiple boring fulfillment handlers", function () {
                testFulfilled(sentinel, function (promise, done) {
                    var handler1 = sinon.stub().returns(other);
                    var handler2 = sinon.stub().returns(other);
                    var handler3 = sinon.stub().returns(other);

                    var spy = sinon.spy();
                    promise.then(handler1, spy);
                    promise.then(handler2, spy);
                    promise.then(handler3, spy);

                    promise.then(function (value) {
                        assert.strictEqual(value, sentinel);

                        sinon.assert.calledWith(handler1, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler2, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler3, sinon.match.same(sentinel));
                        sinon.assert.notCalled(spy);

                        done();
                    });
                });
            });

            describe("multiple fulfillment handlers, one of which throws", function () {
                testFulfilled(sentinel, function (promise, done) {
                    var handler1 = sinon.stub().returns(other);
                    var handler2 = sinon.stub().throws(other);
                    var handler3 = sinon.stub().returns(other);

                    var spy = sinon.spy();
                    promise.then(handler1, spy);
                    promise.then(handler2, spy);
                    promise.then(handler3, spy);

                    promise.then(function (value) {
                        assert.strictEqual(value, sentinel);

                        sinon.assert.calledWith(handler1, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler2, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler3, sinon.match.same(sentinel));
                        sinon.assert.notCalled(spy);

                        done();
                    });
                });
            });

            describe("results in multiple branching chains with their own fulfillment values", function () {
                testFulfilled(dummy, function (promise, done) {
                    var semiDone = callbackAggregator(3, done);

                    promise.then(function () {
                        return sentinel;
                    }).then(function (value) {
                        assert.strictEqual(value, sentinel);
                        semiDone();
                    });

                    promise.then(function () {
                        throw sentinel2;
                    }).then(null, function (reason) {
                        assert.strictEqual(reason, sentinel2);
                        semiDone();
                    });

                    promise.then(function () {
                        return sentinel3;
                    }).then(function (value) {
                        assert.strictEqual(value, sentinel3);
                        semiDone();
                    });
                });
            });

            describe("`onFulfilled` handlers are called in the original order", function () {
                testFulfilled(dummy, function (promise, done) {
                    var handler1 = sinon.spy(function handler1() {});
                    var handler2 = sinon.spy(function handler2() {});
                    var handler3 = sinon.spy(function handler3() {});

                    promise.then(handler1);
                    promise.then(handler2);
                    promise.then(handler3);

                    promise.then(function () {
                        sinon.assert.callOrder(handler1, handler2, handler3);
                        done();
                    });
                });

                describe("even when one handler is added inside another handler", function () {
                    testFulfilled(dummy, function (promise, done) {
                        var handler1 = sinon.spy(function handler1() {});
                        var handler2 = sinon.spy(function handler2() {});
                        var handler3 = sinon.spy(function handler3() {});

                        promise.then(function () {
                            handler1();
                            promise.then(handler3);
                        });
                        promise.then(handler2);

                        promise.then(function () {
                            // Give implementations a bit of extra time to flush their internal queue, if necessary.
                            setTimeout(function () {
                                sinon.assert.callOrder(handler1, handler2, handler3);
                                done();
                            }, 15);
                        });
                    });
                });
            });
        });

        describe("2.2.6.2: If/when `promise` is rejected, all respective `onRejected` callbacks must execute in the " +
                 "order of their originating calls to `then`.", function () {
            describe("multiple boring rejection handlers", function () {
                testRejected(sentinel, function (promise, done) {
                    var handler1 = sinon.stub().returns(other);
                    var handler2 = sinon.stub().returns(other);
                    var handler3 = sinon.stub().returns(other);

                    var spy = sinon.spy();
                    promise.then(spy, handler1);
                    promise.then(spy, handler2);
                    promise.then(spy, handler3);

                    promise.then(null, function (reason) {
                        assert.strictEqual(reason, sentinel);

                        sinon.assert.calledWith(handler1, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler2, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler3, sinon.match.same(sentinel));
                        sinon.assert.notCalled(spy);

                        done();
                    });
                });
            });

            describe("multiple rejection handlers, one of which throws", function () {
                testRejected(sentinel, function (promise, done) {
                    var handler1 = sinon.stub().returns(other);
                    var handler2 = sinon.stub().throws(other);
                    var handler3 = sinon.stub().returns(other);

                    var spy = sinon.spy();
                    promise.then(spy, handler1);
                    promise.then(spy, handler2);
                    promise.then(spy, handler3);

                    promise.then(null, function (reason) {
                        assert.strictEqual(reason, sentinel);

                        sinon.assert.calledWith(handler1, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler2, sinon.match.same(sentinel));
                        sinon.assert.calledWith(handler3, sinon.match.same(sentinel));
                        sinon.assert.notCalled(spy);

                        done();
                    });
                });
            });

            describe("results in multiple branching chains with their own fulfillment values", function () {
                testRejected(sentinel, function (promise, done) {
                    var semiDone = callbackAggregator(3, done);

                    promise.then(null, function () {
                        return sentinel;
                    }).then(function (value) {
                        assert.strictEqual(value, sentinel);
                        semiDone();
                    });

                    promise.then(null, function () {
                        throw sentinel2;
                    }).then(null, function (reason) {
                        assert.strictEqual(reason, sentinel2);
                        semiDone();
                    });

                    promise.then(null, function () {
                        return sentinel3;
                    }).then(function (value) {
                        assert.strictEqual(value, sentinel3);
                        semiDone();
                    });
                });
            });

            describe("`onRejected` handlers are called in the original order", function () {
                testRejected(dummy, function (promise, done) {
                    var handler1 = sinon.spy(function handler1() {});
                    var handler2 = sinon.spy(function handler2() {});
                    var handler3 = sinon.spy(function handler3() {});

                    promise.then(null, handler1);
                    promise.then(null, handler2);
                    promise.then(null, handler3);

                    promise.then(null, function () {
                        sinon.assert.callOrder(handler1, handler2, handler3);
                        done();
                    });
                });

                describe("even when one handler is added inside another handler", function () {
                    testRejected(dummy, function (promise, done) {
                        var handler1 = sinon.spy(function handler1() {});
                        var handler2 = sinon.spy(function handler2() {});
                        var handler3 = sinon.spy(function handler3() {});

                        promise.then(null, function () {
                            handler1();
                            promise.then(null, handler3);
                        });
                        promise.then(null, handler2);

                        promise.then(null, function () {
                            // Give implementations a bit of extra time to flush their internal queue, if necessary.
                            setTimeout(function () {
                                sinon.assert.callOrder(handler1, handler2, handler3);
                                done();
                            }, 15);
                        });
                    });
                });
            });
        });
    });
})();

// File: 2.2.7.js
(function(){
    "use strict";

    var assert = require("assert");
    var testFulfilled = require("./helpers/testThreeCases").testFulfilled;
    var testRejected = require("./helpers/testThreeCases").testRejected;
    var reasons = require("./helpers/reasons");

    var adapter = global.adapter;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it
    var sentinel = { sentinel: "sentinel" }; // a sentinel fulfillment value to test for with strict equality
    var other = { other: "other" }; // a value we don't want to be strict equal to

    describe("2.2.7: `then` must return a promise: `promise2 = promise1.then(onFulfilled, onRejected)`", function () {
        specify("is a promise", function () {
            var promise1 = deferred().promise;
            var promise2 = promise1.then();

            assert(typeof promise2 === "object" || typeof promise2 === "function");
            assert.notStrictEqual(promise2, null);
            assert.strictEqual(typeof promise2.then, "function");
        });

        describe("2.2.7.1: If either `onFulfilled` or `onRejected` returns a value `x`, run the Promise Resolution " +
                 "Procedure `[[Resolve]](promise2, x)`", function () {
            specify("see separate 3.3 tests", function () { });
        });

        describe("2.2.7.2: If either `onFulfilled` or `onRejected` throws an exception `e`, `promise2` must be rejected " +
                 "with `e` as the reason.", function () {
            function testReason(expectedReason, stringRepresentation) {
                describe("The reason is " + stringRepresentation, function () {
                    testFulfilled(dummy, function (promise1, done) {
                        var promise2 = promise1.then(function onFulfilled() {
                            throw expectedReason;
                        });

                        promise2.then(null, function onPromise2Rejected(actualReason) {
                            assert.strictEqual(actualReason, expectedReason);
                            done();
                        });
                    });
                    testRejected(dummy, function (promise1, done) {
                        var promise2 = promise1.then(null, function onRejected() {
                            throw expectedReason;
                        });

                        promise2.then(null, function onPromise2Rejected(actualReason) {
                            assert.strictEqual(actualReason, expectedReason);
                            done();
                        });
                    });
                });
            }

            Object.keys(reasons).forEach(function (stringRepresentation) {
                testReason(reasons[stringRepresentation], stringRepresentation);
            });
        });

        describe("2.2.7.3: If `onFulfilled` is not a function and `promise1` is fulfilled, `promise2` must be fulfilled " +
                 "with the same value.", function () {

            function testNonFunction(nonFunction, stringRepresentation) {
                describe("`onFulfilled` is " + stringRepresentation, function () {
                    testFulfilled(sentinel, function (promise1, done) {
                        var promise2 = promise1.then(nonFunction);

                        promise2.then(function onPromise2Fulfilled(value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });
            }

            testNonFunction(undefined, "`undefined`");
            testNonFunction(null, "`null`");
            testNonFunction(false, "`false`");
            testNonFunction(5, "`5`");
            testNonFunction({}, "an object");
            testNonFunction([function () { return other; }], "an array containing a function");
        });

        describe("2.2.7.4: If `onRejected` is not a function and `promise1` is rejected, `promise2` must be rejected " +
                 "with the same reason.", function () {

            function testNonFunction(nonFunction, stringRepresentation) {
                describe("`onRejected` is " + stringRepresentation, function () {
                    testRejected(sentinel, function (promise1, done) {
                        var promise2 = promise1.then(null, nonFunction);

                        promise2.then(null, function onPromise2Rejected(reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });
            }

            testNonFunction(undefined, "`undefined`");
            testNonFunction(null, "`null`");
            testNonFunction(false, "`false`");
            testNonFunction(5, "`5`");
            testNonFunction({}, "an object");
            testNonFunction([function () { return other; }], "an array containing a function");
        });
    });
})();

// File: 2.3.1.js
(function(){
    "use strict";

    var assert = require("assert");

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.3.1: If `promise` and `x` refer to the same object, reject `promise` with a `TypeError' as the reason.",
             function () {
        specify("via return from a fulfilled promise", function (done) {
            var promise = resolved(dummy).then(function () {
                return promise;
            });

            promise.then(null, function (reason) {
                assert(reason instanceof TypeError);
                done();
            });
        });

        specify("via return from a rejected promise", function (done) {
            var promise = rejected(dummy).then(null, function () {
                return promise;
            });

            promise.then(null, function (reason) {
                assert(reason instanceof TypeError);
                done();
            });
        });
    });
})();

// File: 2.3.2.js
(function(){
    "use strict";

    var assert = require("assert");

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it
    var sentinel = { sentinel: "sentinel" }; // a sentinel fulfillment value to test for with strict equality

    function testPromiseResolution(xFactory, test) {
        specify("via return from a fulfilled promise", function (done) {
            var promise = resolved(dummy).then(function onBasePromiseFulfilled() {
                return xFactory();
            });

            test(promise, done);
        });

        specify("via return from a rejected promise", function (done) {
            var promise = rejected(dummy).then(null, function onBasePromiseRejected() {
                return xFactory();
            });

            test(promise, done);
        });
    }

    describe("2.3.2: If `x` is a promise, adopt its state", function () {
        describe("2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.",
                 function () {
            function xFactory() {
                return deferred().promise;
            }

            testPromiseResolution(xFactory, function (promise, done) {
                var wasFulfilled = false;
                var wasRejected = false;

                promise.then(
                    function onPromiseFulfilled() {
                        wasFulfilled = true;
                    },
                    function onPromiseRejected() {
                        wasRejected = true;
                    }
                );

                setTimeout(function () {
                    assert.strictEqual(wasFulfilled, false);
                    assert.strictEqual(wasRejected, false);
                    done();
                }, 100);
            });
        });

        describe("2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.", function () {
            describe("`x` is already-fulfilled", function () {
                function xFactory() {
                    return resolved(sentinel);
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function onPromiseFulfilled(value) {
                        assert.strictEqual(value, sentinel);
                        done();
                    });
                });
            });

            describe("`x` is eventually-fulfilled", function () {
                var d = null;

                function xFactory() {
                    d = deferred();
                    setTimeout(function () {
                        d.resolve(sentinel);
                    }, 50);
                    return d.promise;
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function onPromiseFulfilled(value) {
                        assert.strictEqual(value, sentinel);
                        done();
                    });
                });
            });
        });

        describe("2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.", function () {
            describe("`x` is already-rejected", function () {
                function xFactory() {
                    return rejected(sentinel);
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(null, function onPromiseRejected(reason) {
                        assert.strictEqual(reason, sentinel);
                        done();
                    });
                });
            });

            describe("`x` is eventually-rejected", function () {
                var d = null;

                function xFactory() {
                    d = deferred();
                    setTimeout(function () {
                        d.reject(sentinel);
                    }, 50);
                    return d.promise;
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(null, function onPromiseRejected(reason) {
                        assert.strictEqual(reason, sentinel);
                        done();
                    });
                });
            });
        });
    });
})();

// File: 2.3.3.js
(function(){
    "use strict";

    var assert = require("assert");
    var thenables = require("./helpers/thenables");
    var reasons = require("./helpers/reasons");

    var adapter = global.adapter;
    var resolved = adapter.resolved;
    var rejected = adapter.rejected;
    var deferred = adapter.deferred;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it
    var sentinel = { sentinel: "sentinel" }; // a sentinel fulfillment value to test for with strict equality
    var other = { other: "other" }; // a value we don't want to be strict equal to
    var sentinelArray = [sentinel]; // a sentinel fulfillment value to test when we need an array

    function testPromiseResolution(xFactory, test) {
        specify("via return from a fulfilled promise", function (done) {
            var promise = resolved(dummy).then(function onBasePromiseFulfilled() {
                return xFactory();
            });

            test(promise, done);
        });

        specify("via return from a rejected promise", function (done) {
            var promise = rejected(dummy).then(null, function onBasePromiseRejected() {
                return xFactory();
            });

            test(promise, done);
        });
    }

    function testCallingResolvePromise(yFactory, stringRepresentation, test) {
        describe("`y` is " + stringRepresentation, function () {
            describe("`then` calls `resolvePromise` synchronously", function () {
                function xFactory() {
                    return {
                        then: function (resolvePromise) {
                            resolvePromise(yFactory());
                        }
                    };
                }

                testPromiseResolution(xFactory, test);
            });

            describe("`then` calls `resolvePromise` asynchronously", function () {
                function xFactory() {
                    return {
                        then: function (resolvePromise) {
                            setTimeout(function () {
                                resolvePromise(yFactory());
                            }, 0);
                        }
                    };
                }

                testPromiseResolution(xFactory, test);
            });
        });
    }

    function testCallingRejectPromise(r, stringRepresentation, test) {
        describe("`r` is " + stringRepresentation, function () {
            describe("`then` calls `rejectPromise` synchronously", function () {
                function xFactory() {
                    return {
                        then: function (resolvePromise, rejectPromise) {
                            rejectPromise(r);
                        }
                    };
                }

                testPromiseResolution(xFactory, test);
            });

            describe("`then` calls `rejectPromise` asynchronously", function () {
                function xFactory() {
                    return {
                        then: function (resolvePromise, rejectPromise) {
                            setTimeout(function () {
                                rejectPromise(r);
                            }, 0);
                        }
                    };
                }

                testPromiseResolution(xFactory, test);
            });
        });
    }

    function testCallingResolvePromiseFulfillsWith(yFactory, stringRepresentation, fulfillmentValue) {
        testCallingResolvePromise(yFactory, stringRepresentation, function (promise, done) {
            promise.then(function onPromiseFulfilled(value) {
                assert.strictEqual(value, fulfillmentValue);
                done();
            });
        });
    }

    function testCallingResolvePromiseRejectsWith(yFactory, stringRepresentation, rejectionReason) {
        testCallingResolvePromise(yFactory, stringRepresentation, function (promise, done) {
            promise.then(null, function onPromiseRejected(reason) {
                assert.strictEqual(reason, rejectionReason);
                done();
            });
        });
    }

    function testCallingRejectPromiseRejectsWith(reason, stringRepresentation) {
        testCallingRejectPromise(reason, stringRepresentation, function (promise, done) {
            promise.then(null, function onPromiseRejected(rejectionReason) {
                assert.strictEqual(rejectionReason, reason);
                done();
            });
        });
    }

    describe("2.3.3: Otherwise, if `x` is an object or function,", function () {
        describe("2.3.3.1: Let `then` be `x.then`", function () {
            describe("`x` is an object with null prototype", function () {
                var numberOfTimesThenWasRetrieved = null;

                beforeEach(function () {
                    numberOfTimesThenWasRetrieved = 0;
                });

                function xFactory() {
                    return Object.create(null, {
                        then: {
                            get: function () {
                                ++numberOfTimesThenWasRetrieved;
                                return function thenMethodForX(onFulfilled) {
                                    onFulfilled();
                                };
                            }
                        }
                    });
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function () {
                        assert.strictEqual(numberOfTimesThenWasRetrieved, 1);
                        done();
                    });
                });
            });

            describe("`x` is an object with normal Object.prototype", function () {
                var numberOfTimesThenWasRetrieved = null;

                beforeEach(function () {
                    numberOfTimesThenWasRetrieved = 0;
                });

                function xFactory() {
                    return Object.create(Object.prototype, {
                        then: {
                            get: function () {
                                ++numberOfTimesThenWasRetrieved;
                                return function thenMethodForX(onFulfilled) {
                                    onFulfilled();
                                };
                            }
                        }
                    });
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function () {
                        assert.strictEqual(numberOfTimesThenWasRetrieved, 1);
                        done();
                    });
                });
            });

            describe("`x` is a function", function () {
                var numberOfTimesThenWasRetrieved = null;

                beforeEach(function () {
                    numberOfTimesThenWasRetrieved = 0;
                });

                function xFactory() {
                    function x() { }

                    Object.defineProperty(x, "then", {
                        get: function () {
                            ++numberOfTimesThenWasRetrieved;
                            return function thenMethodForX(onFulfilled) {
                                onFulfilled();
                            };
                        }
                    });

                    return x;
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function () {
                        assert.strictEqual(numberOfTimesThenWasRetrieved, 1);
                        done();
                    });
                });
            });
        });

        describe("2.3.3.2: If retrieving the property `x.then` results in a thrown exception `e`, reject `promise` with " +
                 "`e` as the reason.", function () {
            function testRejectionViaThrowingGetter(e, stringRepresentation) {
                function xFactory() {
                    return Object.create(Object.prototype, {
                        then: {
                            get: function () {
                                throw e;
                            }
                        }
                    });
                }

                describe("`e` is " + stringRepresentation, function () {
                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, e);
                            done();
                        });
                    });
                });
            }

            Object.keys(reasons).forEach(function (stringRepresentation) {
                testRejectionViaThrowingGetter(reasons[stringRepresentation], stringRepresentation);
            });
        });

        describe("2.3.3.3: If `then` is a function, call it with `x` as `this`, first argument `resolvePromise`, and " +
                 "second argument `rejectPromise`", function () {
            describe("Calls with `x` as `this` and two function arguments", function () {
                function xFactory() {
                    var x = {
                        then: function (onFulfilled, onRejected) {
                            assert.strictEqual(this, x);
                            assert.strictEqual(typeof onFulfilled, "function");
                            assert.strictEqual(typeof onRejected, "function");
                            onFulfilled();
                        }
                    };
                    return x;
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function () {
                        done();
                    });
                });
            });

            describe("Uses the original value of `then`", function () {
                var numberOfTimesThenWasRetrieved = null;

                beforeEach(function () {
                    numberOfTimesThenWasRetrieved = 0;
                });

                function xFactory() {
                    return Object.create(Object.prototype, {
                        then: {
                            get: function () {
                                if (numberOfTimesThenWasRetrieved === 0) {
                                    return function (onFulfilled) {
                                        onFulfilled();
                                    };
                                }
                                return null;
                            }
                        }
                    });
                }

                testPromiseResolution(xFactory, function (promise, done) {
                    promise.then(function () {
                        done();
                    });
                });
            });

            describe("2.3.3.3.1: If/when `resolvePromise` is called with value `y`, run `[[Resolve]](promise, y)`",
                     function () {
                describe("`y` is not a thenable", function () {
                    testCallingResolvePromiseFulfillsWith(function () { return undefined; }, "`undefined`", undefined);
                    testCallingResolvePromiseFulfillsWith(function () { return null; }, "`null`", null);
                    testCallingResolvePromiseFulfillsWith(function () { return false; }, "`false`", false);
                    testCallingResolvePromiseFulfillsWith(function () { return 5; }, "`5`", 5);
                    testCallingResolvePromiseFulfillsWith(function () { return sentinel; }, "an object", sentinel);
                    testCallingResolvePromiseFulfillsWith(function () { return sentinelArray; }, "an array", sentinelArray);
                });

                describe("`y` is a thenable", function () {
                    Object.keys(thenables.fulfilled).forEach(function (stringRepresentation) {
                        function yFactory() {
                            return thenables.fulfilled[stringRepresentation](sentinel);
                        }

                        testCallingResolvePromiseFulfillsWith(yFactory, stringRepresentation, sentinel);
                    });

                    Object.keys(thenables.rejected).forEach(function (stringRepresentation) {
                        function yFactory() {
                            return thenables.rejected[stringRepresentation](sentinel);
                        }

                        testCallingResolvePromiseRejectsWith(yFactory, stringRepresentation, sentinel);
                    });
                });

                describe("`y` is a thenable for a thenable", function () {
                    Object.keys(thenables.fulfilled).forEach(function (outerStringRepresentation) {
                        var outerThenableFactory = thenables.fulfilled[outerStringRepresentation];

                        Object.keys(thenables.fulfilled).forEach(function (innerStringRepresentation) {
                            var innerThenableFactory = thenables.fulfilled[innerStringRepresentation];

                            var stringRepresentation = outerStringRepresentation + " for " + innerStringRepresentation;

                            function yFactory() {
                                return outerThenableFactory(innerThenableFactory(sentinel));
                            }

                            testCallingResolvePromiseFulfillsWith(yFactory, stringRepresentation, sentinel);
                        });

                        Object.keys(thenables.rejected).forEach(function (innerStringRepresentation) {
                            var innerThenableFactory = thenables.rejected[innerStringRepresentation];

                            var stringRepresentation = outerStringRepresentation + " for " + innerStringRepresentation;

                            function yFactory() {
                                return outerThenableFactory(innerThenableFactory(sentinel));
                            }

                            testCallingResolvePromiseRejectsWith(yFactory, stringRepresentation, sentinel);
                        });
                    });
                });
            });

            describe("2.3.3.3.2: If/when `rejectPromise` is called with reason `r`, reject `promise` with `r`",
                     function () {
                Object.keys(reasons).forEach(function (stringRepresentation) {
                    testCallingRejectPromiseRejectsWith(reasons[stringRepresentation], stringRepresentation);
                });
            });

            describe("2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called, or multiple calls to the same " +
                     "argument are made, the first call takes precedence, and any further calls are ignored.",
                     function () {
                describe("calling `resolvePromise` then `rejectPromise`, both synchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                resolvePromise(sentinel);
                                rejectPromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` synchronously then `rejectPromise` asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                resolvePromise(sentinel);

                                setTimeout(function () {
                                    rejectPromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` then `rejectPromise`, both asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                setTimeout(function () {
                                    resolvePromise(sentinel);
                                }, 0);

                                setTimeout(function () {
                                    rejectPromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` with an asynchronously-fulfilled promise, then calling " +
                         "`rejectPromise`, both synchronously", function () {
                    function xFactory() {
                        var d = deferred();
                        setTimeout(function () {
                            d.resolve(sentinel);
                        }, 50);

                        return {
                            then: function (resolvePromise, rejectPromise) {
                                resolvePromise(d.promise);
                                rejectPromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` with an asynchronously-rejected promise, then calling " +
                         "`rejectPromise`, both synchronously", function () {
                    function xFactory() {
                        var d = deferred();
                        setTimeout(function () {
                            d.reject(sentinel);
                        }, 50);

                        return {
                            then: function (resolvePromise, rejectPromise) {
                                resolvePromise(d.promise);
                                rejectPromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `rejectPromise` then `resolvePromise`, both synchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                rejectPromise(sentinel);
                                resolvePromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `rejectPromise` synchronously then `resolvePromise` asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                rejectPromise(sentinel);

                                setTimeout(function () {
                                    resolvePromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `rejectPromise` then `resolvePromise`, both asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                setTimeout(function () {
                                    rejectPromise(sentinel);
                                }, 0);

                                setTimeout(function () {
                                    resolvePromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` twice synchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise) {
                                resolvePromise(sentinel);
                                resolvePromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` twice, first synchronously then asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise) {
                                resolvePromise(sentinel);

                                setTimeout(function () {
                                    resolvePromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` twice, both times asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise) {
                                setTimeout(function () {
                                    resolvePromise(sentinel);
                                }, 0);

                                setTimeout(function () {
                                    resolvePromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` with an asynchronously-fulfilled promise, then calling it again, both " +
                         "times synchronously", function () {
                    function xFactory() {
                        var d = deferred();
                        setTimeout(function () {
                            d.resolve(sentinel);
                        }, 50);

                        return {
                            then: function (resolvePromise) {
                                resolvePromise(d.promise);
                                resolvePromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `resolvePromise` with an asynchronously-rejected promise, then calling it again, both " +
                         "times synchronously", function () {
                    function xFactory() {
                        var d = deferred();
                        setTimeout(function () {
                            d.reject(sentinel);
                        }, 50);

                        return {
                            then: function (resolvePromise) {
                                resolvePromise(d.promise);
                                resolvePromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `rejectPromise` twice synchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                rejectPromise(sentinel);
                                rejectPromise(other);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `rejectPromise` twice, first synchronously then asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                rejectPromise(sentinel);

                                setTimeout(function () {
                                    rejectPromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("calling `rejectPromise` twice, both times asynchronously", function () {
                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                setTimeout(function () {
                                    rejectPromise(sentinel);
                                }, 0);

                                setTimeout(function () {
                                    rejectPromise(other);
                                }, 0);
                            }
                        };
                    }

                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(null, function (reason) {
                            assert.strictEqual(reason, sentinel);
                            done();
                        });
                    });
                });

                describe("saving and abusing `resolvePromise` and `rejectPromise`", function () {
                    var savedResolvePromise, savedRejectPromise;

                    function xFactory() {
                        return {
                            then: function (resolvePromise, rejectPromise) {
                                savedResolvePromise = resolvePromise;
                                savedRejectPromise = rejectPromise;
                            }
                        };
                    }

                    beforeEach(function () {
                        savedResolvePromise = null;
                        savedRejectPromise = null;
                    });

                    testPromiseResolution(xFactory, function (promise, done) {
                        var timesFulfilled = 0;
                        var timesRejected = 0;

                        promise.then(
                            function () {
                                ++timesFulfilled;
                            },
                            function () {
                                ++timesRejected;
                            }
                        );

                        if (savedResolvePromise && savedRejectPromise) {
                            savedResolvePromise(dummy);
                            savedResolvePromise(dummy);
                            savedRejectPromise(dummy);
                            savedRejectPromise(dummy);
                        }

                        setTimeout(function () {
                            savedResolvePromise(dummy);
                            savedResolvePromise(dummy);
                            savedRejectPromise(dummy);
                            savedRejectPromise(dummy);
                        }, 50);

                        setTimeout(function () {
                            assert.strictEqual(timesFulfilled, 1);
                            assert.strictEqual(timesRejected, 0);
                            done();
                        }, 100);
                    });
                });
            });

            describe("2.3.3.3.4: If calling `then` throws an exception `e`,", function () {
                describe("2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.", function () {
                    describe("`resolvePromise` was called with a non-thenable", function () {
                        function xFactory() {
                            return {
                                then: function (resolvePromise) {
                                    resolvePromise(sentinel);
                                    throw other;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(function (value) {
                                assert.strictEqual(value, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`resolvePromise` was called with an asynchronously-fulfilled promise", function () {
                        function xFactory() {
                            var d = deferred();
                            setTimeout(function () {
                                d.resolve(sentinel);
                            }, 50);

                            return {
                                then: function (resolvePromise) {
                                    resolvePromise(d.promise);
                                    throw other;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(function (value) {
                                assert.strictEqual(value, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`resolvePromise` was called with an asynchronously-rejected promise", function () {
                        function xFactory() {
                            var d = deferred();
                            setTimeout(function () {
                                d.reject(sentinel);
                            }, 50);

                            return {
                                then: function (resolvePromise) {
                                    resolvePromise(d.promise);
                                    throw other;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(null, function (reason) {
                                assert.strictEqual(reason, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`rejectPromise` was called", function () {
                        function xFactory() {
                            return {
                                then: function (resolvePromise, rejectPromise) {
                                    rejectPromise(sentinel);
                                    throw other;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(null, function (reason) {
                                assert.strictEqual(reason, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`resolvePromise` then `rejectPromise` were called", function () {
                        function xFactory() {
                            return {
                                then: function (resolvePromise, rejectPromise) {
                                    resolvePromise(sentinel);
                                    rejectPromise(other);
                                    throw other;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(function (value) {
                                assert.strictEqual(value, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`rejectPromise` then `resolvePromise` were called", function () {
                        function xFactory() {
                            return {
                                then: function (resolvePromise, rejectPromise) {
                                    rejectPromise(sentinel);
                                    resolvePromise(other);
                                    throw other;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(null, function (reason) {
                                assert.strictEqual(reason, sentinel);
                                done();
                            });
                        });
                    });
                });

                describe("2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.", function () {
                    describe("straightforward case", function () {
                        function xFactory() {
                            return {
                                then: function () {
                                    throw sentinel;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(null, function (reason) {
                                assert.strictEqual(reason, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`resolvePromise` is called asynchronously before the `throw`", function () {
                        function xFactory() {
                            return {
                                then: function (resolvePromise) {
                                    setTimeout(function () {
                                        resolvePromise(other);
                                    }, 0);
                                    throw sentinel;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(null, function (reason) {
                                assert.strictEqual(reason, sentinel);
                                done();
                            });
                        });
                    });

                    describe("`rejectPromise` is called asynchronously before the `throw`", function () {
                        function xFactory() {
                            return {
                                then: function (resolvePromise, rejectPromise) {
                                    setTimeout(function () {
                                        rejectPromise(other);
                                    }, 0);
                                    throw sentinel;
                                }
                            };
                        }

                        testPromiseResolution(xFactory, function (promise, done) {
                            promise.then(null, function (reason) {
                                assert.strictEqual(reason, sentinel);
                                done();
                            });
                        });
                    });
                });
            });
        });

        describe("2.3.3.4: If `then` is not a function, fulfill promise with `x`", function () {
            function testFulfillViaNonFunction(then, stringRepresentation) {
                var x = null;

                beforeEach(function () {
                    x = { then: then };
                });

                function xFactory() {
                    return x;
                }

                describe("`then` is " + stringRepresentation, function () {
                    testPromiseResolution(xFactory, function (promise, done) {
                        promise.then(function (value) {
                            assert.strictEqual(value, x);
                            done();
                        });
                    });
                });
            }

            testFulfillViaNonFunction(5, "`5`");
            testFulfillViaNonFunction({}, "an object");
            testFulfillViaNonFunction([function () { }], "an array containing a function");
            testFulfillViaNonFunction(/a-b/i, "a regular expression");
            testFulfillViaNonFunction(Object.create(Function.prototype), "an object inheriting from `Function.prototype`");
        });
    });
})();

// File: 2.3.4.js
(function(){
    "use strict";

    var assert = require("assert");
    var testFulfilled = require("./helpers/testThreeCases").testFulfilled;
    var testRejected = require("./helpers/testThreeCases").testRejected;

    var dummy = { dummy: "dummy" }; // we fulfill or reject with this when we don't intend to test against it

    describe("2.3.4: If `x` is not an object or function, fulfill `promise` with `x`", function () {
        function testValue(expectedValue, stringRepresentation, beforeEachHook, afterEachHook) {
            describe("The value is " + stringRepresentation, function () {
                if (typeof beforeEachHook === "function") {
                    beforeEach(beforeEachHook);
                }
                if (typeof afterEachHook === "function") {
                    afterEach(afterEachHook);
                }

                testFulfilled(dummy, function (promise1, done) {
                    var promise2 = promise1.then(function onFulfilled() {
                        return expectedValue;
                    });

                    promise2.then(function onPromise2Fulfilled(actualValue) {
                        assert.strictEqual(actualValue, expectedValue);
                        done();
                    });
                });
                testRejected(dummy, function (promise1, done) {
                    var promise2 = promise1.then(null, function onRejected() {
                        return expectedValue;
                    });

                    promise2.then(function onPromise2Fulfilled(actualValue) {
                        assert.strictEqual(actualValue, expectedValue);
                        done();
                    });
                });
            });
        }

        testValue(undefined, "`undefined`");
        testValue(null, "`null`");
        testValue(false, "`false`");
        testValue(true, "`true`");
        testValue(0, "`0`");

        testValue(
            true,
            "`true` with `Boolean.prototype` modified to have a `then` method",
            function () {
                Boolean.prototype.then = function () {};
            },
            function () {
                delete Boolean.prototype.then;
            }
        );

        testValue(
            1,
            "`1` with `Number.prototype` modified to have a `then` method",
            function () {
                Number.prototype.then = function () {};
            },
            function () {
                delete Number.prototype.then;
            }
        );
    });
})();

    });
})();