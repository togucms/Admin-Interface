<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

<span id='Deft-promise-Consequence'>/**
</span>* @private
* Consequences are used internally by a Resolver to capture and notify
* callbacks, and propagate their transformed results as fulfillment or
* rejection.
*
* Developers never directly interact with a Consequence.
*
* A Consequence forms a chain between two Resolvers, where the result of
* the first Resolver is transformed by the corresponding callback before
* being applied to the second Resolver.
*
* Each time a Resolver's then() method is called, it creates a new
* Consequence that will be triggered once its originating Resolver has
* been fulfilled or rejected. A Consequence captures a pair of optional
* onFulfilled and onRejected callbacks.
*
* Each Consequence has its own Resolver (which in turn has a Promise)
* that is resolved or rejected when the Consequence is triggered. When a
* Consequence is triggered by its originating Resolver, it calls the
* corresponding callback and propagates the transformed result to its own
* Resolver; resolved with the callback return value or rejected with any
* error thrown by the callback.
*/

Ext.define('Deft.promise.Consequence', {
  alternateClassName: ['Deft.Consequence'],
  requires: ['Deft.util.Function'],
<span id='Deft-promise-Consequence-property-promise'>  /**
</span>     * @property {Deft.promise.Promise}
     * Promise of the future value of this Consequence.
  */

  promise: null,
<span id='Deft-promise-Consequence-property-resolver'>  /**
</span>     * @private
     * @property {Deft.promise.Resolver}
     * Internal Resolver for this Consequence.
  */

  resolver: null,
<span id='Deft-promise-Consequence-property-onFulfilled'>  /**
</span>     * @private
     * @property {Function}
     Callback to execute when this Consequence is triggered with a fulfillment value.
  */

  onFulfilled: null,
<span id='Deft-promise-Consequence-property-onRejected'>  /**
</span>     * @private
     * @property {Function}
     Callback to execute when this Consequence is triggered with a rejection reason.
  */

  onRejected: null,
<span id='Deft-promise-Consequence-property-onProgress'>  /**
</span>     * @private
     * @property {Function}
     Callback to execute when this Consequence is updated with a progress value.
  */

  onProgress: null,
<span id='Deft-promise-Consequence-method-constructor'>  /**
</span>  	* @param {Function} onFulfilled Callback to execute to transform a fulfillment value.
  	* @param {Function} onRejected Callback to execute to transform a rejection reason.
  */

  constructor: function(onFulfilled, onRejected, onProgress) {
    this.onFulfilled = onFulfilled;
    this.onRejected = onRejected;
    this.onProgress = onProgress;
    this.resolver = Ext.create('Deft.promise.Resolver');
    this.promise = this.resolver.promise;
    return this;
  },
<span id='Deft-promise-Consequence-method-trigger'>  /**
</span>     * Trigger this Consequence with the specified action and value.
  	*
  	* @param {String} action Completion action (i.e. fulfill or reject).
  	* @param {Mixed} value Fulfillment value or rejection reason.
  */

  trigger: function(action, value) {
    switch (action) {
      case 'fulfill':
        this.propagate(value, this.onFulfilled, this.resolver, this.resolver.resolve);
        break;
      case 'reject':
        this.propagate(value, this.onRejected, this.resolver, this.resolver.reject);
    }
  },
<span id='Deft-promise-Consequence-method-update'>  /**
</span>  	* Update this Consequence with the specified progress value.
  	*
  	* @param {Mixed} value Progress value.
  */

  update: function(progress) {
    if (Deft.isFunction(this.onProgress)) {
      progress = this.onProgress(progress);
    }
    this.resolver.update(progress);
  },
<span id='Deft-promise-Consequence-method-propagate'>  /**
</span>  	* @private
  	* Transform and propagate the specified value using the
     * optional callback and propagate the transformed result.
  	*
  	* @param {Mixed} value Value to transform and/or propagate.
  	* @param {Function} callback (Optional) callback to use to transform the value.
  	* @param {Function} resolver Resolver to use to propagate the value, if no callback was specified.
  	* @param {Function} resolverMethod Resolver method to call to propagate the value, if no callback was specified.
  */

  propagate: function(value, callback, resolver, resolverMethod) {
    if (Deft.isFunction(callback)) {
      this.schedule(function() {
        var error;
        try {
          resolver.resolve(callback(value));
        } catch (_error) {
          error = _error;
          resolver.reject(error);
        }
      });
    } else {
      resolverMethod.call(this.resolver, value);
    }
  },
<span id='Deft-promise-Consequence-method-schedule'>  /**
</span>  	* @private
  	* @method
  	* Schedules the specified callback function to be executed on
     * the next turn of the event loop.
  	*
  	* @param {Function} callback Callback function.
     * @param {Mixed[]} parameters Optional callback parameters.
  	* @param {Object} scope Optional scope for the callback.
  */

  schedule: Ext.emptyFn
}, function() {
  var CallbackQueue, callbackQueue, nextTick;
  nextTick = typeof setImmediate !== &quot;undefined&quot; &amp;&amp; setImmediate !== null ? setImmediate : function(task) {
    return setTimeout(task, 0);
  };
  CallbackQueue = (function() {
    function CallbackQueue() {
      var execute, queuedCallbackCount, queuedCallbacks;
      queuedCallbacks = new Array(1e4);
      queuedCallbackCount = 0;
      execute = function() {
        var index;
        index = 0;
        while (index &lt; queuedCallbackCount) {
          queuedCallbacks[index]();
          queuedCallbacks[index] = null;
          index++;
        }
        queuedCallbackCount = 0;
      };
      this.schedule = function(callback) {
        queuedCallbacks[queuedCallbackCount++] = callback;
        if (queuedCallbackCount === 1) {
          nextTick(execute);
        }
      };
    }

    return CallbackQueue;

  })();
  callbackQueue = new CallbackQueue();
  this.prototype.schedule = function(callback, parameters, scope) {
    callbackQueue.schedule(callback, parameters, scope);
  };
});
</pre>
</body>
</html>
